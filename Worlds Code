#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in2,    driveGyro,      sensorGyro)
#pragma config(Sensor, in3,    BatteryPE,      sensorAnalog)
#pragma config(Sensor, in4,    intakePot,      sensorPotentiometer)
#pragma config(Sensor, dgtl1,  liftBump,       sensorTouch)
#pragma config(Sensor, dgtl2,  rightQuad,      sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  leftQuad,       sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightClaw,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rightDriveOut, tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port3,           rightLift23,   tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port4,           leftDriveIn,   tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port5,           rightDriveIn,  tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port6,           rightLift1,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           leftLift1,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           leftLift23,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           leftDriveOut,  tmotorVex393_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port10,          leftClaw,      tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Power Expander 5A,6B,7C
#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

#define resetBump SensorValue(liftBump)
#define intakePos SensorValue(intakePot)
#define gyroPos SensorValue(driveGyro)
#define rDrive SensorValue(rightQuad) //nMotorEncoder[rightDriveIn]
#define lDrive SensorValue(leftQuad) //nMotorEncoder[leftDriveIn]
#define liftPos nMotorEncoder[rightLift23]

/////////////////////////////////////////////////////////////////////////////////////////
//
//Global Variables Start
//
/////////////////////////////////////////////////////////////////////////////////////////
//Lift Variables
int liftTarget = 1;

//Intake Variables
int intakeTarget;
const int closePos = 390, openSmallPos = 265, openWidePos = 240, open180Pos = 178, openTinyPos = 290;

//Drive Variables (PID)
char* driveDirection;
int driveTarget;
int encoderDerivative;

//Drive Variables(Slew Control)
int rightDriveSpeed = 0, leftDriveSpeed = 0;

//LCD Auton-Selection
int autonSide = 10, selectedAuton = 10, cubeVariation = 10, fenceVariation = 10;
bool autonSideSelected = false, autonSelected = false, cubeVariationSelected = false, fenceVariationSelected = false;
string autonDescription = "None Selected", autonSideDescription;

//LCD Drive Display
string cortexBattery, expanderBattery, backupBattery;
string rightDriveDisplay, leftDriveDisplay, gyroDisplay;
string intakeDisplay;
string liftDisplay, liftBumpDisplay;
bool mainBattery = true;
void initializeGyro();
/////////////////////////////////////////////////////////////////////////////////////////
//Global Variables End
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
//
//LCD	Control Start
//
/////////////////////////////////////////////////////////////////////////////////////////
/*bool abort()
{
	if(time1(T2) > 3000) return false;
	else return true;
}
bool obstruction(){
	if(encoderDerivative == 0 && time1[T2] > 300) return true;
	else return false;
}*/
void clearLCD()//clear LCD screen
{
	clearLCDLine(0);
	clearLCDLine(1);
}
void waitForRelease()	//improve lcd button usability
{
	while(nLCDButtons != 0){}
	wait1Msec(10);
}
void selectAuton() //auton selection
{
	//select auton side (right/left/skills)
	clearLCD();
	autonSelected = false;
	autonSideSelected = false;
	cubeVariationSelected = false;
	fenceVariationSelected = false;
	bLCDBacklight = true;
	while(autonSideSelected == false && bIfiAutonomousMode == false && abs(vexRT[Ch1]) < 15 && abs(vexRT[Ch3]) < 15){
		if (nLCDButtons == 1) {
			waitForRelease();
			autonSide--;
			clearLCD();
		} //end if
		else if (nLCDButtons == 4){
			waitForRelease();
			autonSide++;
			clearLCD();
		} //end else if
		else if (nLCDButtons == 2) {
			waitForRelease();
			autonSideSelected = true;
			clearLCD();
		} //end else if

		if(autonSide < 1) autonSide = 3; //allows for infinite scrolling
		else if(autonSide > 3) autonSide = 1;

		switch(autonSide){
		case 1:
			displayLCDCenteredString(0, "Side: Left");
			displayLCDCenteredString(1, "<		Enter		>");
			break;
		case 2:
			displayLCDCenteredString(0, "Side: Right");
			displayLCDCenteredString(1, "<		Enter		>");
			break;
		case 3:
			displayLCDCenteredString(0, "Skills");
			displayLCDCenteredString(1, "<		Enter		>");
			break;
		default:
			displayLCDCenteredString(0, "Error");
			displayLCDCenteredString(1, "You goofed!");
			break;
		} //end switch case
		wait1Msec(100); //don't hog cpu
	}//end while loop

	if (autonSide == 1) autonSideDescription = "Left";
	else if (autonSide == 2) autonSideDescription = "Right";
	else if (autonSide == 3) {
		autonSideDescription = "";
		autonDescription = "P Skills";
		selectedAuton = 4;
	} //end else if
	else autonSideDescription = "";

	//select auton
	clearLCD();
	if(autonSide == 1 || autonSide == 2){
		while(autonSelected == false && bIfiAutonomousMode == false && abs(vexRT[Ch1]) < 15 && abs(vexRT[Ch3]) < 15){ //break early for joystick
			if(nLCDButtons == 1) {
				waitForRelease();
				selectedAuton--;
				clearLCD();
			}//end if
			else if(nLCDButtons == 4) {
				waitForRelease();
				selectedAuton++;
				clearLCD();
			}//end else if
			else if(nLCDButtons == 2) {
				waitForRelease();
				autonSelected = true;
				clearLCD();
			}//end else if

			if(selectedAuton < 1) selectedAuton = 2; //allows for infinite scrolling
			else if(selectedAuton > 2) selectedAuton = 1;

			switch(selectedAuton){
			case 1:
				sprintf(autonDescription, "%s: Cube", autonSideDescription);
				displayLCDCenteredString(0, autonDescription);
				displayLCDCenteredString(1, "<		Enter		>");
				break;
			case 2:
				sprintf(autonDescription, "%s:FenceStars", autonSideDescription);
				displayLCDCenteredString(0, autonDescription);
				displayLCDCenteredString(1, "<		Enter		>");
				break;
				/*case 3:
				sprintf(autonDescription, "%s:BackStars", autonSideDescription);
				displayLCDCenteredString(0, autonDescription);
				displayLCDCenteredString(1, "<		Enter		>");
				break;*/
			default:
				autonDescription = "None Selected";
				displayLCDCenteredString(0, "Error");
				displayLCDCenteredString(1, "You goofed!");
			}//end switch case
			wait1Msec(100);
		}//end while loop
	}//end if statement

	clearLCD();
	if(selectedAuton == 1){ //variations of cube auton
		while(cubeVariationSelected == false && bIfiAutonomousMode == false && abs(vexRT[Ch1]) < 15 && abs(vexRT[Ch3]) < 15){
			if (nLCDButtons == 1) {
				waitForRelease();
				cubeVariation--;
				clearLCD();
			} //end if
			else if (nLCDButtons == 4){
				waitForRelease();
				cubeVariation++;
				clearLCD();
			} //end else if
			else if (nLCDButtons == 2) {
				waitForRelease();
				cubeVariationSelected = true;
				clearLCD();
			} //end else if

			if(cubeVariation < 1) cubeVariation = 2; //allows for infinite scrolling
			else if(cubeVariation > 2) cubeVariation = 1;

			switch(cubeVariation){
			case 1:
				sprintf(autonDescription, "%s:FrontBlock", autonSideDescription);
				displayLCDCenteredString(0, autonDescription);
				displayLCDCenteredString(1, "<		Enter		>");
				break;
			case 2:
				sprintf(autonDescription, "%s:Cube+1Run", autonSideDescription);
				displayLCDCenteredString(0, autonDescription);
				displayLCDCenteredString(1, "<		Enter		>");
				break;
			default:
				displayLCDCenteredString(0, "Error");
				displayLCDCenteredString(1, "You goofed!");
				break;
			}//end switch case
			wait1Msec(100);
		}//end while loop statement
	} //end if statementf
	else if (selectedAuton == 2){
		while(fenceVariationSelected == false && bIfiAutonomousMode == false && abs(vexRT[Ch1]) < 15 && abs(vexRT[Ch3]) < 15){
			if (nLCDButtons == 1) {
				waitForRelease();
				fenceVariation--;
				clearLCD();
			} //end if
			else if (nLCDButtons == 4){
				waitForRelease();
				fenceVariation++;
				clearLCD();
			} //end else if
			else if (nLCDButtons == 2) {
				waitForRelease();
				fenceVariationSelected = true;
				clearLCD();
			} //end else if

			if(fenceVariation < 1) fenceVariation = 3; //allows for infinite scrolling
			else if(fenceVariation > 3) fenceVariation = 1;

			switch(fenceVariation){
			case 1:
				sprintf(autonDescription, "%s:GetCube", autonSideDescription);
				displayLCDCenteredString(0, autonDescription);
				displayLCDCenteredString(1, "<		Enter		>");
				break;
			case 2:
				sprintf(autonDescription, "%s:Get3Stars", autonSideDescription);
				displayLCDCenteredString(0, autonDescription);
				displayLCDCenteredString(1, "<		Enter		>");
				break;
			case 3:
				sprintf(autonDescription, "%s:GetCorner", autonSideDescription);
				displayLCDCenteredString(0, autonDescription);
				displayLCDCenteredString(1, "<		Enter		>");
				break;
			default:
				displayLCDCenteredString(0, "Error");
				displayLCDCenteredString(1, "You goofed!");
				break;
			}//end switch case
			wait1Msec(100);
		}//end while loop statement
	}
}//end selectAuton
void displayBattery() //display battery levels on lcd
{
	if(nLCDButtons == 2) {
		if(mainBattery == true) mainBattery = false;
		else mainBattery = true;
		clearLCD();
	}
	if(mainBattery == true) {
		displayLCDString(0, 0, "Cortex: "); //Display the Cortex battery voltage
		sprintf(cortexBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0, 'V'); //Build the value to be displayed
		displayNextLCDString(cortexBattery);

		displayLCDString(1, 0, "Expander: "); //Display the Power Expander battery voltage
		sprintf(expanderBattery, "%1.2f%c", (float)SensorValue(BatteryPE)/182.4, 'V'); //Build the value to be displayed
		displayNextLCDString(expanderBattery);
	}
	else {
		displayLCDString(0, 0, "Backup: "); //Display the Backup battery voltage
		sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0, 'V');	//Build the value to be displayed
		displayNextLCDString(backupBattery);
	}
}
void displayTeamInfo() //display team ID
{
	displayLCDCenteredString(0, "Team 333X");
	displayLCDCenteredString(1, "VEX Starstruck");
	if(nLCDButtons == 2){
		waitForRelease();
		if(bLCDBacklight == false) bLCDBacklight = true;
		else bLCDBacklight = false;
	}
}
void displayCurrentAuton() //display selected auton
{
	displayLCDCenteredString(0, "Current Auton:");
	displayLCDCenteredString(1, autonDescription);
	if(nLCDButtons == 2) {
		waitForRelease();
		selectAuton();
	}
}
void displayDriveEncoders() //display drive encoder values
{
	sprintf(leftDriveDisplay, "Drive(L): %d", -lDrive);
	sprintf(rightDriveDisplay, "Drive(R): %d", rDrive);
	displayLCDString(0, 0, leftDriveDisplay);
	displayLCDString(1, 0, rightDriveDisplay);
}
void displayGyro() //display gyro value
{
	sprintf(gyroDisplay, "Gyro: %d", gyroPos);
	displayLCDString(0, 0, gyroDisplay);
	if(nLCDButtons == 2) {
		waitForRelease();
		initializeGyro();
	}
}
void displayIntakePot() //display intake potentiometer values
{
	sprintf(intakeDisplay, "Intake: %d", intakePos);
	displayLCDString(0, 0, intakeDisplay);
}
void displayLiftSensors() //display lift encoder and bump switch
{
	sprintf(liftDisplay, "Lift: %d", liftPos);
	sprintf(liftBumpDisplay, "Reset: %d", resetBump);
	displayLCDString(0, 0, liftDisplay);
	displayLCDString(1, 0, liftBumpDisplay);
}

task matchDisplayLCD(){
	bLCDBacklight = true; //turn off lcd backlight
	clearLCD();
	int lcdState = 1;
	while(true){
		if(nLCDButtons == 1) {
			waitForRelease();
			lcdState--;
			clearLCD();
		}//end if
		else if (nLCDButtons == 4) {
			waitForRelease();
			lcdState++;
			clearLCD();
		}//end else if


		if(lcdState < 1) lcdState = 7; //infinite scrolling
		else if(lcdState > 7) lcdState = 1; //infinite scrolling

		switch(lcdState){
		case 1:
			displayTeamInfo();
			break;
		case 2:
			displayCurrentAuton();
			break;
		case 3:
			displayBattery();
			break;
		case 4:
			displayDriveEncoders();
			break;
		case 5:
			displayGyro();
			break;
		case 6:
			displayIntakePot();
			break;
		case 7:
			displayLiftSensors();
			break;
		default:
			displayTeamInfo();
			break;
		}//end switch case
		wait1Msec(200);
	}//end while loop
}//end task

/////////////////////////////////////////////////////////////////////////////////////////
//LCD	Control End
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
//
//Basic Movement Start
//
/////////////////////////////////////////////////////////////////////////////////////////
//DRIVE FUNCTIONS
void stopDrive()
{
	motor[rightDriveIn] = 0;
	motor[rightDriveOut] = 0;
	motor[leftDriveIn] = 0;
	motor[leftDriveOut] = 0;
}
void driveBack(int speed)
{
	motor[rightDriveIn] = 0 - speed;
	motor[rightDriveOut] = 0 - speed;
	motor[leftDriveIn] = 0 - speed;
	motor[leftDriveOut] = 0 - speed;
}
void leftTurn(int speed)
{
	motor[rightDriveIn] = speed;
	motor[rightDriveOut] = speed;
	motor[leftDriveIn] = 0 - speed;
	motor[leftDriveOut] = 0 - speed;
}
void manualDrive()
{
	motor[leftDriveIn]  = leftDriveSpeed;
	motor[leftDriveOut]  = leftDriveSpeed;
	motor[rightDriveIn] = rightDriveSpeed;
	motor[rightDriveOut] = rightDriveSpeed;
}
void initializeSensors()
{
	clearLCD();
	displayLCDCenteredString(0, "Initializing");
	displayLCDCenteredString(1, "Sensors...");
	SensorType[in1] = sensorNone; //clear previous sensor readings
	SensorType[in2] = sensorNone; //clear previous sensor readings
	SensorType[in3] = sensorNone; //clear previous sensor readings
	liftPos = sensorNone; //clear previous sensor readings
	rDrive = sensorNone; //clear previous sensor readings
	lDrive = sensorNone; //clear previous sensor readings
	wait1Msec(300);
	SensorType[in1] = sensorPotentiometer; //reconfigure port as potentiometer
	SensorType[in2] = sensorGyro; //reconfigure port as gyro
	SensorType[in3] = sensorAnalog; //reconfigure port as analog
	liftPos = sensorQuadEncoderOnI2CPort; //reconfigure port as IME
	rDrive = sensorQuadEncoder; //reconfigure port as Quad Encoder
	lDrive = sensorQuadEncoder; //reconfigure port as Quad Encoder
	wait1Msec(1500);
}
void initializeGyro()
{
	clearLCD();
	displayLCDCenteredString(0, "Initializing");
	displayLCDCenteredString(1, "Gyro...");
	SensorType[in2] = sensorNone; //clear previous sensor readings
	wait1Msec(300);
	SensorType[in2] = sensorGyro; //reconfigure port as gyro
	wait1Msec(1500);
	clearLCD();
}
void setDrive(char* direction, int target)
{
	driveDirection = direction;
	driveTarget = target;
	rDrive = 0;
	lDrive = 0;
	gyroPos = 0;
	clearTimer(T2);
}

//LIFT FUNCTIONS
void lift(int speed)
{
	motor[rightLift1] = speed;
	motor[rightLift23] = speed;
	motor[leftLift1] = speed;
	motor[leftLift23] = speed;
}
void liftStop()
{
	motor[rightLift1] = 0;
	motor[rightLift23] = 0;
	motor[leftLift1] = 0;
	motor[leftLift23] = 0;
}
void manualLift()
{
	//if(liftPos < 100){
	if(vexRT[Btn6U] == 1) lift(120);
	else if(vexRT[Btn6D] == 1) {
		if(resetBump == 1) lift(-20);
		else lift(-120);
	}
	else if(vexRT[Btn8U] == 1) lift(50);
	else if(vexRT[Btn8D] == 1) {
		if(resetBump == 1) lift(-20);
		else lift(-50);
	}
	else if(resetBump == 1) lift(-15);
	else liftStop();
	/*}
	else {
	if(vexRT[Btn6U] == 1) liftTarget = liftPos + 67;
	else if(vexRT[Btn6D] == 1) liftTarget = liftPos - 67;
	else if(vexRT[Btn8U] == 1) liftTarget = liftPos + 30;
	else if(vexRT[Btn8D] == 1) liftTarget = liftPos - 30;
	//else if(resetBump == 1) lift(-15);
	else liftStop();

	if(liftTarget < 0) liftTarget = 0;
	else if(liftTarget > 1000) liftTarget = 1000;
	}*/
}
void setLift(float target)
{
	liftTarget = target;
}

void liftReset()
{
	setLift(-150);
	waitUntil(resetBump == 1);
	setLift(0);
}

//INTAKE FUNCTIONS
void intakeOpen(int speed)
{
	motor[leftClaw] = 0 - speed;
	motor[rightClaw] = 0 - speed;
}
void intakeClose(int speed)
{
	motor[leftClaw] = speed;
	motor[rightClaw] = speed;
}
void intakeStop()
{
	motor[leftClaw] = 0;
	motor[rightClaw] = 0;
}
void manualIntake(){
	if(vexRT[Btn7U] == true) intakeClose(120);
	else if(vexRT[Btn7D] == true) intakeOpen(120);
	else intakeStop();
}
void setIntake(float target)
{
	intakeTarget = target;
}

/////////////////////////////////////////////////////////////////////////////////////////
//Basic Movement End
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
//
//Drive/Lift/Intake Control Tasks Start
//
/////////////////////////////////////////////////////////////////////////////////////////
task driveSlewRateControl(){
	int	leftJoy, rightJoy;
	int rightTarget = 0, rightAccel = 0; //right target/accel
	int leftTarget = 0, leftAccel = 0; //left target/accel
	float turnScale;

	const int maxAcceleration = 20;

	while(true){
		if(abs(vexRT[Ch1]) > 15) rightJoy = vexRT[Ch1]; //set right joystick threshold
		else rightJoy = 0;

		if(abs(vexRT[Ch3]) > 15) leftJoy = vexRT[Ch3]; //set left joystick threshold
		else leftJoy = 0;

		if(resetBump == 1) turnScale = 0.8;
		else turnScale = 0.95;

		if(leftJoy == 0) rightJoy *= turnScale;

		//calculate right speed
		if(resetBump == 1) rightTarget = (-rightJoy + leftJoy) * (100./127);
		else rightTarget = (-rightJoy + leftJoy) * (100./127);
		rightAccel = rightTarget - rightDriveSpeed;

		if(rightAccel > maxAcceleration) rightAccel = maxAcceleration;
		else if (rightAccel < 0 - maxAcceleration) rightAccel = 0 - maxAcceleration;

		if(rightAccel != 0) rightDriveSpeed += rightAccel;

		//calculate left speed
		if(resetBump == 1) leftTarget = (rightJoy + leftJoy) * (100./127);
		else leftTarget = (rightJoy + leftJoy) * (100./127);
		leftAccel = leftTarget - leftDriveSpeed;

		if(leftAccel > maxAcceleration) leftAccel = maxAcceleration;
		else if (leftAccel < 0 - maxAcceleration) leftAccel = 0 - maxAcceleration;

		if(leftAccel != 0) leftDriveSpeed += leftAccel;

		wait1Msec(20);
	}
}

task driveControlAuton(){
	bool gyroPID;
	bool encoderPID;

	//ENCODER VARIABLES
	int rightEncoderVal;
	int leftEncoderVal;
	int encoderAverageVal;
	int driftVal;
	int encoderError;
	int encoderErrorPrevious;
	int encoderProportion;
	int encoderIntegral;
	//int encoderDerivative;
	int encoderDriveRaw;
	int driftError;
	int driftRaw;

	//GYRO VARIABLES
	int gyroVal;
	int gyroError = 1;
	int gyroErrorPrevious = 0;
	int gyroProportion;
	int gyroIntegral;
	int gyroDerivative;
	int gyroDriveRaw;


	//ENCODER PID CONSTANTS
	const float encoderKp = 0.65/* / encoderConversion*/;//0.7//.8
	const float encoderKi = 0.0;
	const float encoderKd = 4/* / encoderConversion*/; //2.5//4.0
	const float driftKp = 0.2;
	const int encoderMaxPower = 120;
	const int encoderMinPower = -120;

	//GYRO PID CONSTANTS
	const float gyroKp = 0.4;
	const float gyroKi = 0.00000;
	const float gyroKd = 1.9; //1.8
	const int gyroMaxPower = 90;
	const int gyroMinPower = -90;

	const int integralLimit = 50; //integral limit

	int driveState = 3;
	while(true){
		if(driveDirection == "forward" || driveDirection == "back") driveState = 1;
		else if (driveDirection == "right" || driveDirection == "left") driveState = 2;
		else if (driveTarget == -99999) driveState = 3;
		else driveState = 4;

		switch(driveState){
		case 1: // pid w/ encoders for driving straight
			gyroPID = false;
			encoderPID = true;
			break;
		case 2: //pid w/ gyro for turning
			encoderPID = false;
			gyroPID = true;
			break;
		case 3: //no pid, allow values from elsewhere in program
			encoderPID = false;
			gyroPID = false;
			break;
		case 4: //no pid, motor values = 0
			encoderPID = false;
			gyroPID = false;
			stopDrive();
			break;
		default:
			stopDrive();
			break;
		} //end switchcase

		if (encoderPID == true){
			if(driveDirection == "back") driveTarget = abs(driveTarget) * -1; //set target to match direction

			rightEncoderVal = rDrive;
			leftEncoderVal = lDrive;
			driftVal = gyroPos;
			rightEncoderVal *= 1; //correct encoder count direction if necessary
			leftEncoderVal *= -1; //correct encoder count direction if necessary
			encoderAverageVal = /*(rightEncoderVal + leftEncoderVal) / 2;*/ rightEncoderVal; //Only use right side, left is broken
			encoderError = (driveTarget/* * encoderConversion*/) - encoderAverageVal; //E = Target - actual

			if(encoderKi != 0){
				if(abs(encoderError) < integralLimit) encoderIntegral += encoderError;
				else if(encoderError > integralLimit) encoderIntegral = integralLimit;
				else if(encoderError < 0 - integralLimit) encoderIntegral = 0 - integralLimit;
				else encoderIntegral = 0;
			}//end if(Ki != 0)
			else {
				encoderIntegral = 0;
				encoderIntegral = 0;
			}//end else statement

			encoderProportion = encoderKp * encoderError; //calculate proportion
			encoderDerivative = encoderKd * (encoderError - encoderErrorPrevious); //calculate derivative
			encoderErrorPrevious = encoderError; //set "previous error"
			encoderIntegral *= encoderKi; // calculate integral

			encoderDriveRaw = encoderProportion + encoderIntegral + encoderDerivative; //calculate motor value
			if(encoderDriveRaw > encoderMaxPower) encoderDriveRaw = encoderMaxPower;
			else if(encoderDriveRaw < encoderMinPower) encoderDriveRaw = encoderMinPower;

			driftError = 0 - driftVal; //E = target - actual
			driftRaw = driftKp * driftError;

			motor[rightDriveOut] = encoderDriveRaw + driftRaw;//apply motor values
			motor[rightDriveIn] = encoderDriveRaw + driftRaw;
			motor[leftDriveOut] = encoderDriveRaw - driftRaw;
			motor[leftDriveIn] = encoderDriveRaw - driftRaw;
			writeDebugStreamLine("prop:%d, der:%d", encoderProportion, encoderDerivative);
		} //end if encoderPID == true
		else{ //clear all
			rightEncoderVal = 0;
			leftEncoderVal = 0;
			encoderAverageVal = 0;
			driftVal = 0;
			encoderError = 0;
			encoderErrorPrevious = 0;
			encoderProportion = 0;
			encoderIntegral = 0;
			encoderDerivative = 0;
			encoderDriveRaw = 0;
			driftError = 0;
			driftRaw = 0;
		} //end else statement

		if (gyroPID == true){
			if(driveDirection == "right") driveTarget = abs(driveTarget) * -1;
			gyroVal = gyroPos;
			gyroError = driveTarget - gyroVal;

			if(gyroKi != 0){//calculate integral
				if(abs(gyroError) < integralLimit) gyroIntegral += gyroError;
				else if(gyroError > integralLimit) gyroIntegral = integralLimit;
				else if(gyroError < 0 - integralLimit) gyroIntegral = 0 - integralLimit;
				else gyroIntegral = 0;
			}//end if(Ki!=0) statement
			else gyroIntegral = 0;

			gyroProportion = gyroKp*gyroError; //calculate proportion
			gyroDerivative = gyroKd*(gyroError-gyroErrorPrevious); //calculate derivative
			gyroErrorPrevious = gyroError; //set "previous error"
			gyroIntegral *= gyroKi;

			gyroDriveRaw = gyroProportion+gyroDerivative+gyroIntegral; //calculate motor power values
			if(gyroDriveRaw > gyroMaxPower) gyroDriveRaw = gyroMaxPower;
			else if(gyroDriveRaw < gyroMinPower) gyroDriveRaw = gyroMinPower;

			leftTurn(gyroDriveRaw); //if gdr > 0 turns left, if gdr < 0 turns right
		}//end if gyroPID == true
		else{
			gyroVal = 0;
			gyroError = 0;
			gyroErrorPrevious = 0;
			gyroProportion = 0;
			gyroIntegral = 0;
			gyroDerivative = 0;
			gyroDriveRaw = 0;
		} //end else statement

		wait1Msec(20); //don't hog cpu
	} //end while loop
} //end task

task liftControl(){
	bool pidRunning = false; //boolean to activate/deactivate PID
	int liftState = 1;

	//PID Variables
	int encoderVal;
	int error;
	int lastError;
	int proportion;
	float integral;
	int derivative;
	int liftRaw;

	//PID Constants
	const float Kp = 1.8;
	const float Ki = 0.0;
	const float Kd = 5.0;
	const int integralLimit = 50;
	const int maxPower = 80;
	const int minPower = -127;

	bool fenceLow = false; //toggle fence height

	while (true){
		if(SensorValue[liftBump] != 0) liftPos = 0; //recalibrate lift encoder @ down position

		if(bIfiAutonomousMode == true){ //allow values to be sent from elsewhere in program
			liftState = 5;
		}//end if statement
		else{
			if(vexRT[Btn6U] == 1 || vexRT[Btn6D] == 1 || vexRT[Btn8U] == 1 || vexRT[Btn8D] == 1) liftState = 1;
			else if(vexRT[Btn8R] == 1) {
				clearTimer(T3);
				liftState = 2;
			}
			else if(vexRT[Btn8L] == 1) {
				waitUntil(vexRT[Btn8L] != 1); //wait for release
				if(fenceLow == true) fenceLow = false;
				else if (fenceLow == false) fenceLow = true;
				liftState = 3;
			}
			else if (vexRT[Btn7R] == 1) liftState = 4;
		}//end else statement

		switch(liftState){
		case 1: //manual controls
			/*if(liftPos < 100) pidRunning = false;
			else pidRunning = true;*/
			pidRunning = false;
			manualLift();
			break;
		case 2: //lift up to prevent intake drag
			if(resetBump == 0 && liftPos == 0){
				pidRunning = false;
				lift(100);
				waitUntil(time1(T3) > 250);
				lift(15);
			}
			else {
				pidRunning = true;
				setLift(175);
			}
			break;
		case 3: //knock stars off fence
			if(resetBump == 0 && liftPos == 0){}
			else{
				pidRunning = true;
				if(fenceLow == true) setLift(380); //if fence is set to low
				else setLift(480);
			}
			break;
		case 4: //manual lock
			pidRunning = false;
			lift(20);
			break;
		case 5: //auton
			if(liftTarget == -999/* || liftTarget == 0*/) pidRunning = false;
			else pidRunning = true;
			break;
		default: //default manual
			pidRunning = false;
			manualLift();
			break;
		}//end switch case

		if(pidRunning == true){
			encoderVal = liftPos;
			encoderVal *= 1; //correct encoder count direction if necessary
			error = liftTarget - encoderVal; //E = target - encoder

			if(Ki != 0.0){//calculate integral
				if(abs(error) < integralLimit) integral += error;
				else if(error > integralLimit) integral = integralLimit;
				else if(error < 0 - integralLimit) integral = 0 - integralLimit;
				else integral = 0;
			}//end if(Ki!=0) statement
			else integral = 0;

			proportion = Kp*error; //calculate proportion
			derivative = Kd*(error-lastError); //calculate derivative
			lastError = error; //set "previous error"
			integral *= Ki;

			liftRaw = proportion+derivative+integral; //calculate motor power values
			if(liftRaw > maxPower) liftRaw = 127;
			else if(liftRaw < minPower) liftRaw = -127;
			lift(liftRaw);//apply motor values
		}//end if(pidRunning) == true
		else{
			encoderVal = 0;
			error = 0;
			lastError = 0;
			proportion = 0;
			integral = 0;
			derivative = 0;
			liftRaw = 0;
		}//end else statement
		wait1Msec(20);//don't hog cpu
	}//end while loop
}//end task

task intakeControl(){
	bool pidRunning = false; //boolean to activate/deactivate PID
	int intakeState = 1;

	//Left PID variables
	int potVal;
	int error;
	int errorPrevious;
	int proportion;
	int integral;
	int derivative;
	int intakeRaw;

	//PID CONSTANTS
	const int scale = 10;
	const float Kp = 0.3 * scale;
	const float Ki = 0.0;
	const float Kd = 0.5 * scale;
	const int integralLimit = 50;
	const int maxPower = 120;
	const int minPower = -120;

	while(true){
		if(bIfiAutonomousMode == true){ //allow values to be sent from elsewhere in program
			intakeState = 6;
		}//end if statement
		else{
			if(vexRT[Btn7U] == 1 || vexRT[Btn7D] == 1) intakeState = 1;
			else if(vexRT[Btn5U] == 1) {
				intakeState = 2;
				clearTimer(T1);
			}
			else if(vexRT[Btn5D] == 1) intakeState = 3;
			else if(vexRT[Btn7L] == 1) intakeState = 4;
			else if(vexRT[Btn8L] == 1) intakeState = 5;
		}//end else statement
		switch(intakeState){ //intakeState determines code segment
		case 1: //Manual controls
			pidRunning = false;
			manualIntake();
			break;
		case 2: //Closed Preset w/ PID
			pidRunning = true;
			if(time1(T1) > 200){
				if(abs(derivative) < 5 && intakePos / scale < closePos + 20){
					setIntake(intakePos / scale + 20);
				}
			}
			else setIntake(closePos);
			break;
		case 3: //Narrow Open (small clumps)
			pidRunning = true;
			setIntake(openTinyPos);//openSmallPos
			break;
		case 4: //Wide Open (large clumps)
			pidRunning = true;
			setIntake(openWidePos);
			break;
		case 5: //knock stuff of fence
			pidRunning = true;
			setIntake(openWidePos);
		case 6: //Auton
			if(intakeTarget == -999) pidRunning = false;
			else pidRunning = true;
			break;
		default: //Default manual
			pidRunning = false;
			manualIntake();
			break;
		}//end switch case

		if(pidRunning == true){
			potVal = intakePos / scale;
			error = intakeTarget - potVal; //calculate error

			if(Ki != 0){
				if(abs(error) < integralLimit) integral += error;
				else if(error > integralLimit) integral = integralLimit;
				else if(error < 0 - integralLimit) integral = 0 - integralLimit;
				else integral = 0;
			}//end if(Ki != 0)
			else {
				integral = 0;
			}//end else statement

			proportion = Kp * error; //calculate proportion
			derivative = Kd * (error - errorPrevious); //calculate derivative
			errorPrevious = error; //set "previous error"
			integral *= Ki; // calculate integral

			intakeRaw = proportion + integral + derivative; //calculate motor value
			if(intakeRaw > maxPower) intakeRaw = 127;
			else if(intakeRaw < minPower) intakeRaw = -127;

			motor[rightClaw] = intakeRaw;//apply motor values
			motor[leftClaw] = intakeRaw;
			//if(abs(derivative) < 5) clearTimer(T1);
		}//end if(pidRunning == true)
		else { //clear all
			potVal = 0;
			error = 0;
			errorPrevious = 0;
			proportion = 0;
			integral = 0;
			derivative = 0;
			intakeRaw = 0;
		}//end else statement
		wait1Msec(20);//don't hog cpu
	}//end while loop
}//end task

/////////////////////////////////////////////////////////////////////////////////////////
//Drive/Lift/Intake Control Tasks End
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
//
//Autonomous Pattern Functions Start
//
/////////////////////////////////////////////////////////////////////////////////////////
//Auton Dump
void autonDump() //dump function for autonomous
{
	setLift(-999); //disable PID
	lift(127);//activate lift full power
	waitUntil(liftPos >= 700); //800//wait to reach release height
	setIntake(openSmallPos); //set intake open
	waitUntil(liftPos >= 830);//1328//follow through
	setLift(liftPos);//set lift stopping point
	wait1Msec(400);
	setIntake(closePos);//close intake after follow through
	waitUntil(intakePos <= 3700);//wait for intake to close
	setLift(-5);//lift down
	waitUntil(liftPos <= 600);//wait for lift to clear fence
	setIntake(openSmallPos);//reset intake to grab
}

void loadCycle(int backTarget) //3s to load objects, intake closes, drives to fence, dumps, straightens
{
	setDrive("back", backTarget); //drive to fence
	setLift(175);
	waitUntil(abs(rDrive) >= (backTarget - 500));
	autonDump(); //dump, reset intake
	waitUntil(liftPos < 160); //&& getMotorVelocity(rightDriveFront) == 0);
	setDrive("null", -99999);
	driveBack(60); //straighten drive against fence
	wait1Msec(400);
	stopDrive();
}
/////////////////////////////////////////////////////////////////////////////////////////
//Autonomous Pattern Functions End
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
//
//Autons Start
//
/////////////////////////////////////////////////////////////////////////////////////////
void cube(char* side)
{
	if(cubeVariation == 1) {
		//front dump
		setLift(275);
		setDrive("forward", 560);
		waitUntil(liftPos > 230);
		setIntake(openSmallPos);
		waitUntil(abs(rDrive) > 300);
		liftReset();
		setIntake(closePos);
		waitUntil(intakePos > 2800);
		wait1Msec(300);
		setLift(450);
		setDrive("forward", 450);
		waitUntil(abs(rDrive) > 360);
		setDrive(side, 600);
		waitUntil(abs(gyroPos) > 575);
		setDrive("forward", 800);
		waitUntil(abs(rDrive) > 730);
		setIntake(openSmallPos);
		wait1Msec(500);
		setDrive("back", 300);
		wait1Msec(800);
		setIntake(open180Pos);
		setDrive("forward", 350);
		wait1Msec(500);
		setIntake(closePos);
		setDrive("forward", rDrive);
		/*setDrive("back", 500);
		wait1Msec(1000);
		liftReset();
		waitUntil(resetBump == 1);
		setIntake(openSmallPos);*/
	}
	else if (cubeVariation == 2){
		setDrive("forward", 50);
		wait1Msec(100);
		setDrive("back", 1450);
		setLift(350);
		setIntake(openWidePos);
		waitUntil(abs(rDrive) > 1400);
		setDrive(side, 350);
		waitUntil(abs(gyroPos) > 300);
		wait1Msec(400);
		setDrive("forward", 75);
		liftReset();
		setIntake(closePos);
		wait1Msec(500);
		loadCycle(300);

		setIntake(openWidePos);
		setDrive("forward", 1050);
		waitUntil(abs(rDrive) > 1000);
		setIntake(closePos);
		wait1Msec(500);
		loadCycle(1050);
	}
}

void backStars(char* side)
{
	setDrive("forward", 500);
}

void fence(char* side)
{

	setDrive("forward", 1600);
	setLift(470);
	setIntake(open180Pos);
	waitUntil(abs(rDrive) > 1520);
	wait1Msec(500);
	setLift(510);
	wait1Msec(200);

	if(fenceVariation == 1){ //Get cube
		setDrive("back", 800);
		waitUntil(abs(rDrive) > 770);
		liftReset();
		setIntake(openWidePos);
		if(side == "right") setDrive("left", 1030);
		else setDrive("right", 1030);
		waitUntil(abs(gyroPos) > 1000);
		wait1Msec(200);
		setDrive("forward", 750);
		wait1Msec(600);
		setIntake(closePos);
		wait1Msec(400);
		setLift(175);
		setDrive("back", 1250);
		wait1Msec(1000);
		if(side == "right") setDrive("left", 900);
		else setDrive("right", 900);
		waitUntil(abs(gyroPos) > 900);
		wait1Msec(200);
		loadCycle(700);

		setIntake(openWidePos);
		setDrive("forward", 1050);
		waitUntil(abs(rDrive) > 1000);
		setIntake(closePos);
		wait1Msec(600);
		loadCycle(1050);

	}
	else if (fenceVariation == 2){ //Back 3 stars
		setDrive("back", 1530);
		setIntake(openSmallPos + 30);
		waitUntil(abs(rDrive) > 1500);

		if(side == "right") setDrive("left", 1030);
		else setDrive("right", 1030);
		waitUntil(abs(gyroPos) > 1000);
		setDrive("back", 300);
		liftReset();
		setDrive("forward", 1300);
		waitUntil(abs(rDrive) > 1200);
		setIntake(closePos);
		wait1Msec(400);
		setLift(300);
		setDrive("back", 1300);
		waitUntil(abs(rDrive) > 1200);
		if(side == "right") setDrive("left", 900);
		else setDrive("right", 900);
		wait1Msec(1000);
		loadCycle(1100);

		setIntake(openWidePos);
		setDrive("forward", 1050);
		waitUntil(abs(rDrive) > 1000);
		setIntake(closePos);
		wait1Msec(600);
		loadCycle(1050);
	}
	else if(fenceVariation == 3){ //Get preload
		setDrive("back", 700);
		wait1Msec(1000);
		liftReset();
		setIntake(openWidePos);
		waitUntil(abs(rDrive) > 675);
		wait1Msec(300);
		if(side == "right") setDrive("left", 2000);
		else setDrive("right", 2000);
		waitUntil(abs(gyroPos) > 1870);
		wait1Msec(300);
		setDrive("forward", 550);
		waitUntil(abs(rDrive) > 500);
		setIntake(closePos);
		wait1Msec(600);
		loadCycle(1050);
	}
}

void programming() //programming skills for red
{

}

void autonExecution()
{
	setDrive("null", 0);
	setLift(-999); //disable lift PID
	setIntake(-999); //disable intake PID
	intakeStop(); //intake motors to 0
	liftStop(); //lift motors to 0
	stopDrive(); //drive motors to 0
	clearLCD(); // clear lcd display
	liftPos = 10;
	gyroPos = 0;
	switch(selectedAuton){ //Switch Case runs selected auton
	case 1:
		displayLCDCenteredString(0, autonDescription);
		displayLCDCenteredString(1, "is running!");
		if(autonSide == 1) cube("left");
		else if(autonSide == 2) cube("right");
		break;
	case 2:
		displayLCDCenteredString(0, autonDescription);
		displayLCDCenteredString(1, "is running!");
		if(autonSide == 1) fence("left");
		else if(autonSide == 2) fence("right");
		break;
	case 3:
		displayLCDCenteredString(0, autonDescription);
		displayLCDCenteredString(1, "is running!");
		if(autonSide == 1) backStars("left");
		else if(autonSide == 2) backStars("right");
		break;
	case 4:
		displayLCDCenteredString(0, "Prgm Skills");
		displayLCDCenteredString(1, "is running!");
		programming();
		break;
	default:
		displayLCDCenteredString(0, "No valid choice");
		displayLCDCenteredString(1, "You goofed!");
		break;
	}//end switch case
}//end autonExecution
/////////////////////////////////////////////////////////////////////////////////////////
//Autons End
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
//
//void pre_auton(), task autonomous(), and task usercontrol() Start
//
/////////////////////////////////////////////////////////////////////////////////////////
void pre_auton(){
	selectAuton();
	if(autonSideSelected == true) initializeSensors();
}
task autonomous(){
	stopTask(driveSlewRateControl);
	stopTask(matchDisplayLCD);
	startTask(liftControl);
	startTask(intakeControl);
	startTask(driveControlAuton);
	autonExecution();
}
task usercontrol(){
	stopTask(driveControlAuton);
	startTask(driveSlewRateControl);
	startTask(liftControl);
	startTask(intakeControl);
	startTask(matchDisplayLCD);
	while(true){
		manualDrive();
		wait1Msec(20); //don't hog cpu
	}//end while loop
}//end task
/////////////////////////////////////////////////////////////////////////////////////////
//void pre_auton(), task autonomous(), and task usercontrol() End
/////////////////////////////////////////////////////////////////////////////////////////
